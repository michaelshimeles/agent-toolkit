/**
 * AI Builder - Convex Actions for generating MCP servers
 */

import { v } from "convex/values";
import { action, query, mutation } from "./_generated/server";
import { api } from "./_generated/api";
import {
  generateMCPFromOpenAPI,
  generateMCPFromDocs,
  analyzeGitHubRepo as analyzeRepo,
  generateDocumentation as generateDocs,
} from "../lib/claude";
import {
  deployMCPServer,
  checkMCPServerHealth,
} from "../lib/vercel";

// Action to generate MCP server from OpenAPI spec
export const generateFromOpenAPI = action({
  args: {
    specUrl: v.string(),
    userId: v.id("users"),
  },
  handler: async (ctx, { specUrl, userId }): Promise<any> => {
    // 1. Fetch and parse OpenAPI spec
    const specResponse = await fetch(specUrl);
    if (!specResponse.ok) {
      throw new Error(`Failed to fetch OpenAPI spec: ${specResponse.statusText}`);
    }

    const spec = await specResponse.json();

    // 2. Extract basic info
    const name = spec.info?.title || "Generated API Server";
    const description = spec.info?.description || "MCP server generated from OpenAPI spec";
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, "-");

    // 3. Parse endpoints and schemas
    const endpoints = parseOpenAPIEndpoints(spec);
    const schemas = extractOpenAPISchemas(spec);

    // 4. Generate MCP tools using Claude API
    const { code: generatedCode, tools } = await generateMCPCode({
      name,
      description,
      endpoints,
      schemas,
      sourceType: "openapi",
    });

    // 5. Store draft in Convex
    const serverId: any = await ctx.runMutation(api.ai.createDraftServer, {
      userId,
      slug,
      name,
      description,
      sourceType: "openapi",
      sourceUrl: specUrl,
      code: generatedCode,
      tools,
    });

    return { serverId, preview: generatedCode };
  },
});

// Action to generate MCP server from documentation URL
export const generateFromDocsUrl = action({
  args: {
    docsUrl: v.string(),
    userId: v.id("users"),
  },
  handler: async (ctx, { docsUrl, userId }): Promise<any> => {
    // 1. Fetch documentation page
    const docsResponse = await fetch(docsUrl);
    if (!docsResponse.ok) {
      throw new Error(`Failed to fetch documentation: ${docsResponse.statusText}`);
    }

    const docsHtml = await docsResponse.text();

    // 2. Use Claude to analyze documentation and generate MCP server
    const analysis = await analyzeAPIDocumentation(docsHtml, docsUrl);

    // 3. Use the code and tools generated by Claude directly
    const generatedCode = analysis.code;
    const tools = analysis.tools;

    // 4. Store draft
    const slug = analysis.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
    const serverId: any = await ctx.runMutation(api.ai.createDraftServer, {
      userId,
      slug,
      name: analysis.name,
      description: analysis.description,
      sourceType: "docs_url",
      sourceUrl: docsUrl,
      code: generatedCode,
      tools,
    });

    return { serverId, preview: generatedCode };
  },
});

// Action to generate MCP server from GitHub repo
export const generateFromGitHubRepo = action({
  args: {
    repoUrl: v.string(),
    userId: v.id("users"),
  },
  handler: async (ctx, { repoUrl, userId }): Promise<any> => {
    // 1. Parse GitHub URL
    const match = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    if (!match) {
      throw new Error("Invalid GitHub URL");
    }

    const [, owner, repo] = match;
    const repoName = repo.replace(/\.git$/, "");

    // 2. Fetch repository info
    const repoInfo = await fetch(`https://api.github.com/repos/${owner}/${repoName}`);
    if (!repoInfo.ok) {
      throw new Error("Repository not found");
    }

    const repoData = await repoInfo.json();

    // 3. Analyze repository structure
    const analysis = await analyzeGitHubRepo(owner, repoName);

    // 4. Generate MCP code
    const { code: generatedCode, tools } = await generateMCPCode({
      name: repoData.name,
      description: repoData.description || "MCP server generated from GitHub repository",
      endpoints: analysis.endpoints,
      schemas: analysis.schemas,
      sourceType: "github_repo",
    });

    // 5. Store draft
    const slug = repoName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
    const serverId: any = await ctx.runMutation(api.ai.createDraftServer, {
      userId,
      slug,
      name: repoData.name,
      description: repoData.description || "Generated from GitHub",
      sourceType: "github_repo",
      sourceUrl: repoUrl,
      code: generatedCode,
      tools,
    });

    return { serverId, preview: generatedCode };
  },
});

// Mutation to create draft server
export const createDraftServer = mutation({
  args: {
    userId: v.id("users"),
    slug: v.string(),
    name: v.string(),
    description: v.string(),
    sourceType: v.union(
      v.literal("openapi"),
      v.literal("docs_url"),
      v.literal("github_repo"),
      v.literal("postman"),
      v.literal("text")
    ),
    sourceUrl: v.optional(v.string()),
    code: v.string(),
    tools: v.array(
      v.object({
        name: v.string(),
        description: v.string(),
        schema: v.any(),
      })
    ),
  },
  handler: async (ctx, args) => {
    const serverId = await ctx.db.insert("generatedServers", {
      userId: args.userId,
      slug: args.slug,
      name: args.name,
      description: args.description,
      sourceType: args.sourceType,
      sourceUrl: args.sourceUrl,
      code: args.code,
      tools: args.tools,
      status: "draft",
      allowedDomains: [],
      rateLimit: 100,
      version: 1,
    });

    return serverId;
  },
});

// Query to list user's generated servers
export const listUserServers = query({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, { userId }) => {
    const servers = await ctx.db
      .query("generatedServers")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .collect();

    return servers;
  },
});

// Query to get a specific server
export const getServer = query({
  args: {
    serverId: v.id("generatedServers"),
  },
  handler: async (ctx, { serverId }) => {
    const server = await ctx.db.get(serverId);
    return server;
  },
});

// Action to deploy server to Vercel
export const deployServer = action({
  args: {
    serverId: v.id("generatedServers"),
  },
  handler: async (ctx, { serverId }) => {
    const server = await ctx.runQuery(api.ai.getServer, { serverId });
    if (!server) {
      throw new Error("Server not found");
    }

    // Update status to deploying
    await ctx.runMutation(api.ai.updateServerStatus, {
      serverId,
      status: "deploying",
    });

    try {
      // Deploy to Vercel (placeholder - would use Vercel API)
      const deploymentUrl = await deployToVercel(server);

      // Update status to deployed
      await ctx.runMutation(api.ai.updateServerStatus, {
        serverId,
        status: "deployed",
        deploymentUrl,
      });

      // Generate documentation
      await ctx.runAction(api.ai.generateDocumentation, { serverId });

      return { url: deploymentUrl, status: "deployed" };
    } catch (error: any) {
      await ctx.runMutation(api.ai.updateServerStatus, {
        serverId,
        status: "failed",
      });
      throw error;
    }
  },
});

// Mutation to update server status
export const updateServerStatus = mutation({
  args: {
    serverId: v.id("generatedServers"),
    status: v.union(
      v.literal("analyzing"),
      v.literal("generating"),
      v.literal("draft"),
      v.literal("deploying"),
      v.literal("deployed"),
      v.literal("failed")
    ),
    deploymentUrl: v.optional(v.string()),
  },
  handler: async (ctx, { serverId, status, deploymentUrl }) => {
    await ctx.db.patch(serverId, {
      status,
      ...(deploymentUrl && { deploymentUrl }),
    });
  },
});

// Action to generate documentation
export const generateDocumentation = action({
  args: {
    serverId: v.id("generatedServers"),
  },
  handler: async (ctx, { serverId }) => {
    const server = await ctx.runQuery(api.ai.getServer, { serverId });
    if (!server) {
      throw new Error("Server not found");
    }

    // Generate documentation using Claude
    const docs = await generateDocsHelper(server.code, server.tools);

    // Update server with documentation
    await ctx.runMutation(api.ai.updateServerDocs, {
      serverId,
      readme: docs.readme,
      toolDocs: docs.toolDocs,
    });
  },
});

// Mutation to update server documentation
export const updateServerDocs = mutation({
  args: {
    serverId: v.id("generatedServers"),
    readme: v.string(),
    toolDocs: v.array(
      v.object({
        name: v.string(),
        description: v.string(),
        params: v.string(),
        example: v.string(),
      })
    ),
  },
  handler: async (ctx, { serverId, readme, toolDocs }) => {
    await ctx.db.patch(serverId, {
      readme,
      toolDocs,
    });
  },
});

// Helper functions (these would use Claude API in production)

function parseOpenAPIEndpoints(spec: any): any[] {
  const endpoints = [];

  for (const [path, methods] of Object.entries(spec.paths || {})) {
    for (const [method, details] of Object.entries(methods as any)) {
      if (["get", "post", "put", "patch", "delete"].includes(method)) {
        endpoints.push({
          path,
          method: method.toUpperCase(),
          operationId: (details as any).operationId,
          summary: (details as any).summary,
          description: (details as any).description,
          parameters: (details as any).parameters || [],
          requestBody: (details as any).requestBody,
          responses: (details as any).responses,
        });
      }
    }
  }

  return endpoints;
}

function extractOpenAPISchemas(spec: any): any {
  return spec.components?.schemas || {};
}

async function generateMCPCode(params: {
  name: string;
  description: string;
  endpoints: any[];
  schemas: any;
  sourceType: string;
}): Promise<{ code: string; tools: any[] }> {
  // Use real Claude API to generate MCP server code
  const spec = {
    info: {
      title: params.name,
      description: params.description,
    },
    paths: {},
    components: {
      schemas: params.schemas,
    },
  };

  // Convert endpoints to OpenAPI paths format
  for (const endpoint of params.endpoints) {
    const path = endpoint.path || "/";
    if (!(spec.paths as any)[path]) {
      (spec.paths as any)[path] = {};
    }
    const method = (endpoint.method || "get").toLowerCase();
    (spec.paths as any)[path][method] = {
      operationId: endpoint.operationId,
      summary: endpoint.summary,
      description: endpoint.description,
      parameters: endpoint.parameters,
      requestBody: endpoint.requestBody,
      responses: endpoint.responses,
    };
  }

  const result = await generateMCPFromOpenAPI(spec);
  return {
    code: result.code,
    tools: result.tools || [],
  };
}

function extractToolsFromCode(code: string): any[] {
  // Try to extract tool definitions from TypeScript code
  const tools: any[] = [];
  
  // Look for tool definitions in the code - match patterns like:
  // { name: "tool_name", description: "...", inputSchema: {...} }
  const toolMatches = code.matchAll(/\{\s*name:\s*["']([^"']+)["']\s*,\s*description:\s*["']([^"']+)["']/g);
  
  for (const match of toolMatches) {
    const [, name, description] = match;
    if (name && description) {
      tools.push({
        name,
        description,
        schema: {
          type: "object",
          properties: {},
        },
      });
    }
  }
  
  // If no tools found via regex, try JSON parsing as fallback
  if (tools.length === 0) {
    try {
      const parsed = JSON.parse(code);
      if (parsed.endpoints) {
        return parsed.endpoints.map((endpoint: any) => ({
          name: endpoint.operationId || `${endpoint.method}_${endpoint.path}`.toLowerCase(),
          description: endpoint.summary || endpoint.description || "",
          schema: {
            type: "object",
            properties: {},
          },
        }));
      }
      if (parsed.tools) {
        return parsed.tools;
      }
    } catch {
      // Not JSON, that's expected for TypeScript code
    }
  }
  
  return tools;
}

async function analyzeAPIDocumentation(
  html: string,
  url: string
): Promise<{
  name: string;
  description: string;
  endpoints: any[];
  schemas: any;
  code: string;
  tools: any[];
}> {
  // Use real Claude API to analyze documentation
  try {
    const result = await generateMCPFromDocs(html, url);
    return {
      name: result.name || "Unknown API",
      description: result.description || "Generated from documentation",
      endpoints: result.endpoints || [],
      schemas: {},
      code: result.code || "",
      tools: result.tools || [],
    };
  } catch (error) {
    console.error("Failed to analyze API documentation:", error);
    throw new Error(
      `Failed to analyze API documentation from ${url}: ${error instanceof Error ? error.message : "Unknown error"}`
    );
  }
}

async function analyzeGitHubRepo(
  owner: string,
  repo: string
): Promise<{
  endpoints: any[];
  schemas: any;
}> {
  // Supported file extensions for code analysis
  const codeExtensions = [
    ".ts", ".js", ".tsx", ".jsx", // JavaScript/TypeScript
    ".go",                        // Go
    ".py",                        // Python
    ".rs",                        // Rust
    ".java",                      // Java
    ".rb",                        // Ruby
    ".php",                       // PHP
  ];
  
  // API-related file patterns (higher priority)
  const apiPatterns = [
    "openapi", "swagger", "api", "route", "controller", 
    "handler", "endpoint", "server", "rest", "http"
  ];
  
  // Config files that might contain API info
  const configFiles = [
    "openapi.yaml", "openapi.yml", "openapi.json",
    "swagger.yaml", "swagger.yml", "swagger.json",
    "api.yaml", "api.yml", "api.json"
  ];

  const relevantFiles: Array<{ path: string; content: string }> = [];
  const maxFiles = 15;
  const maxContentSize = 8000;
  const maxTotalSize = 50000;
  let totalSize = 0;

  // Helper to check if file is relevant
  const isRelevantFile = (path: string): boolean => {
    const lowerPath = path.toLowerCase();
    return codeExtensions.some(ext => lowerPath.endsWith(ext)) ||
           configFiles.some(cf => lowerPath.endsWith(cf));
  };

  // Helper to score file relevance (higher = more relevant for API analysis)
  const scoreFile = (path: string): number => {
    const lowerPath = path.toLowerCase();
    let score = 0;
    
    // Boost for API-related patterns in path
    for (const pattern of apiPatterns) {
      if (lowerPath.includes(pattern)) score += 10;
    }
    
    // Boost for config files
    for (const cf of configFiles) {
      if (lowerPath.endsWith(cf)) score += 50;
    }
    
    // Penalize test files
    if (lowerPath.includes("test") || lowerPath.includes("spec")) score -= 5;
    
    // Penalize vendor/deps
    if (lowerPath.includes("vendor") || lowerPath.includes("node_modules")) score -= 100;
    
    return score;
  };

  // Recursive function to explore directories
  async function exploreDirectory(path: string, depth: number = 0): Promise<Array<{ path: string; download_url: string; score: number }>> {
    if (depth > 3) return []; // Limit depth to avoid too deep recursion
    
    const apiUrl = path 
      ? `https://api.github.com/repos/${owner}/${repo}/contents/${path}`
      : `https://api.github.com/repos/${owner}/${repo}/contents`;
    
    const response = await fetch(apiUrl, {
      headers: {
        "Accept": "application/vnd.github.v3+json",
        "User-Agent": "MCP-App-Store"
      }
    });

    if (!response.ok) {
      console.warn(`Failed to fetch ${apiUrl}: ${response.status}`);
      return [];
    }

    const items = await response.json();
    if (!Array.isArray(items)) return [];

    const foundFiles: Array<{ path: string; download_url: string; score: number }> = [];

    // Priority directories to explore
    const priorityDirs = ["api", "pkg", "internal", "src", "cmd", "server", "routes", "handlers", "controllers"];
    
    // Sort items: priority directories first, then by name
    const sortedItems = [...items].sort((a, b) => {
      if (a.type === "dir" && b.type === "dir") {
        const aIsPriority = priorityDirs.some(d => a.name.toLowerCase().includes(d));
        const bIsPriority = priorityDirs.some(d => b.name.toLowerCase().includes(d));
        if (aIsPriority && !bIsPriority) return -1;
        if (!aIsPriority && bIsPriority) return 1;
      }
      return 0;
    });

    for (const item of sortedItems) {
      // Skip vendor, node_modules, and hidden directories
      if (item.name.startsWith(".") || 
          item.name === "vendor" || 
          item.name === "node_modules" ||
          item.name === "__pycache__") {
        continue;
      }

      if (item.type === "file" && isRelevantFile(item.path)) {
        foundFiles.push({
          path: item.path,
          download_url: item.download_url,
          score: scoreFile(item.path)
        });
      } else if (item.type === "dir" && depth < 3) {
        // Explore subdirectories (with depth limit)
        const subFiles = await exploreDirectory(item.path, depth + 1);
        foundFiles.push(...subFiles);
      }
      
      // Stop if we have enough high-scoring files
      if (foundFiles.filter(f => f.score > 0).length >= maxFiles * 2) {
        break;
      }
    }

    return foundFiles;
  }

  // Explore the repository
  const allFiles = await exploreDirectory("");
  
  // Sort by score and take top files
  allFiles.sort((a, b) => b.score - a.score);
  const topFiles = allFiles.slice(0, maxFiles);

  if (topFiles.length === 0) {
    throw new Error(
      `No relevant code files found in repository ${owner}/${repo}. ` +
      `Supported file types: ${codeExtensions.join(", ")}. ` +
      `Make sure the repository contains source code files.`
    );
  }

  // Download file contents
  for (const file of topFiles) {
    if (totalSize >= maxTotalSize) break;
    
    try {
      const contentResponse = await fetch(file.download_url, {
        headers: { "User-Agent": "MCP-App-Store" }
      });
      
      if (contentResponse.ok) {
        const content = await contentResponse.text();
        const truncatedContent = content.slice(0, maxContentSize);
        relevantFiles.push({
          path: file.path,
          content: truncatedContent,
        });
        totalSize += truncatedContent.length;
      }
    } catch (err) {
      console.warn(`Failed to download ${file.path}:`, err);
    }
  }

  if (relevantFiles.length === 0) {
    throw new Error(
      `Failed to download any code files from repository ${owner}/${repo}. ` +
      `Please check if the repository is accessible.`
    );
  }

  console.log(`Analyzing ${relevantFiles.length} files from ${owner}/${repo}:`, 
    relevantFiles.map(f => f.path));

  // Use Claude to analyze the code
  const result = await analyzeRepo(relevantFiles);

  return {
    endpoints: result.endpoints || [],
    schemas: {},
  };
}

async function deployToVercel(server: any): Promise<string> {
  // Use real Vercel API to deploy
  const result = await deployMCPServer({
    serverName: server.slug,
    serverCode: server.code,
    env: {},
  });

  // Check health
  const health = await checkMCPServerHealth(result.url);
  if (!health.ok) {
    throw new Error(`Deployment health check failed: ${health.error}`);
  }

  return result.url;
}

async function generateDocsHelper(
  code: string,
  tools: any[]
): Promise<{
  readme: string;
  toolDocs: any[];
}> {
  // Use real Claude API to generate documentation
  return await generateDocs(code, tools);
}
