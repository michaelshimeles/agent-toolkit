/**
 * AI Builder - Convex Actions for generating MCP servers
 */

import { v } from "convex/values";
import { action, query, mutation } from "./_generated/server";
import { api } from "./_generated/api";
import {
  generateMCPFromOpenAPI,
  generateMCPFromDocs,
  analyzeGitHubRepo as analyzeRepo,
  generateDocumentation as generateDocs,
} from "../lib/claude";
import {
  deployMCPServer,
  checkMCPServerHealth,
} from "../lib/vercel";

// Action to generate MCP server from OpenAPI spec
export const generateFromOpenAPI = action({
  args: {
    specUrl: v.string(),
    userId: v.id("users"),
  },
  handler: async (ctx, { specUrl, userId }): Promise<any> => {
    // 1. Fetch and parse OpenAPI spec
    const specResponse = await fetch(specUrl);
    if (!specResponse.ok) {
      throw new Error(`Failed to fetch OpenAPI spec: ${specResponse.statusText}`);
    }

    const spec = await specResponse.json();

    // 2. Extract basic info
    const name = spec.info?.title || "Generated API Server";
    const description = spec.info?.description || "MCP server generated from OpenAPI spec";
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, "-");

    // 3. Parse endpoints and schemas
    const endpoints = parseOpenAPIEndpoints(spec);
    const schemas = extractOpenAPISchemas(spec);

    // 4. Generate MCP tools using Claude API
    const generatedCode = await generateMCPCode({
      name,
      description,
      endpoints,
      schemas,
      sourceType: "openapi",
    });

    // 5. Validate generated code
    const tools = extractToolsFromCode(generatedCode);

    // 6. Store draft in Convex
    const serverId: any = await ctx.runMutation(api.ai.createDraftServer, {
      userId,
      slug,
      name,
      description,
      sourceType: "openapi",
      sourceUrl: specUrl,
      code: generatedCode,
      tools,
    });

    return { serverId, preview: generatedCode };
  },
});

// Action to generate MCP server from documentation URL
export const generateFromDocsUrl = action({
  args: {
    docsUrl: v.string(),
    userId: v.id("users"),
  },
  handler: async (ctx, { docsUrl, userId }): Promise<any> => {
    // 1. Fetch documentation page
    const docsResponse = await fetch(docsUrl);
    if (!docsResponse.ok) {
      throw new Error(`Failed to fetch documentation: ${docsResponse.statusText}`);
    }

    const docsHtml = await docsResponse.text();

    // 2. Use Claude to analyze documentation and extract API structure
    const analysis = await analyzeAPIDocumentation(docsHtml, docsUrl);

    // 3. Generate MCP code
    const generatedCode = await generateMCPCode({
      name: analysis.name,
      description: analysis.description,
      endpoints: analysis.endpoints,
      schemas: analysis.schemas,
      sourceType: "docs_url",
    });

    // 4. Extract tools
    const tools = extractToolsFromCode(generatedCode);

    // 5. Store draft
    const slug = analysis.name.toLowerCase().replace(/[^a-z0-9]+/g, "-");
    const serverId = await ctx.runMutation(api.ai.createDraftServer, {
      userId,
      slug,
      name: analysis.name,
      description: analysis.description,
      sourceType: "docs_url",
      sourceUrl: docsUrl,
      code: generatedCode,
      tools,
    });

    return { serverId, preview: generatedCode };
  },
});

// Action to generate MCP server from GitHub repo
export const generateFromGitHubRepo = action({
  args: {
    repoUrl: v.string(),
    userId: v.id("users"),
  },
  handler: async (ctx, { repoUrl, userId }) => {
    // 1. Parse GitHub URL
    const match = repoUrl.match(/github\.com\/([^\/]+)\/([^\/]+)/);
    if (!match) {
      throw new Error("Invalid GitHub URL");
    }

    const [, owner, repo] = match;
    const repoName = repo.replace(/\.git$/, "");

    // 2. Fetch repository info
    const repoInfo = await fetch(`https://api.github.com/repos/${owner}/${repoName}`);
    if (!repoInfo.ok) {
      throw new Error("Repository not found");
    }

    const repoData = await repoInfo.json();

    // 3. Analyze repository structure
    const analysis = await analyzeGitHubRepo(owner, repoName);

    // 4. Generate MCP code
    const generatedCode = await generateMCPCode({
      name: repoData.name,
      description: repoData.description || "MCP server generated from GitHub repository",
      endpoints: analysis.endpoints,
      schemas: analysis.schemas,
      sourceType: "github_repo",
    });

    // 5. Extract tools
    const tools = extractToolsFromCode(generatedCode);

    // 6. Store draft
    const slug = repoName.toLowerCase().replace(/[^a-z0-9]+/g, "-");
    const serverId = await ctx.runMutation(api.ai.createDraftServer, {
      userId,
      slug,
      name: repoData.name,
      description: repoData.description || "Generated from GitHub",
      sourceType: "github_repo",
      sourceUrl: repoUrl,
      code: generatedCode,
      tools,
    });

    return { serverId, preview: generatedCode };
  },
});

// Mutation to create draft server
export const createDraftServer = mutation({
  args: {
    userId: v.id("users"),
    slug: v.string(),
    name: v.string(),
    description: v.string(),
    sourceType: v.union(
      v.literal("openapi"),
      v.literal("docs_url"),
      v.literal("github_repo"),
      v.literal("postman"),
      v.literal("text")
    ),
    sourceUrl: v.optional(v.string()),
    code: v.string(),
    tools: v.array(
      v.object({
        name: v.string(),
        description: v.string(),
        schema: v.any(),
      })
    ),
  },
  handler: async (ctx, args) => {
    const serverId = await ctx.db.insert("generatedServers", {
      userId: args.userId,
      slug: args.slug,
      name: args.name,
      description: args.description,
      sourceType: args.sourceType,
      sourceUrl: args.sourceUrl,
      code: args.code,
      tools: args.tools,
      status: "draft",
      allowedDomains: [],
      rateLimit: 100,
      version: 1,
    });

    return serverId;
  },
});

// Query to list user's generated servers
export const listUserServers = query({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, { userId }) => {
    const servers = await ctx.db
      .query("generatedServers")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .collect();

    return servers;
  },
});

// Query to get a specific server
export const getServer = query({
  args: {
    serverId: v.id("generatedServers"),
  },
  handler: async (ctx, { serverId }) => {
    const server = await ctx.db.get(serverId);
    return server;
  },
});

// Action to deploy server to Vercel
export const deployServer = action({
  args: {
    serverId: v.id("generatedServers"),
  },
  handler: async (ctx, { serverId }) => {
    const server = await ctx.runQuery(api.ai.getServer, { serverId });
    if (!server) {
      throw new Error("Server not found");
    }

    // Update status to deploying
    await ctx.runMutation(api.ai.updateServerStatus, {
      serverId,
      status: "deploying",
    });

    try {
      // Deploy to Vercel (placeholder - would use Vercel API)
      const deploymentUrl = await deployToVercel(server);

      // Update status to deployed
      await ctx.runMutation(api.ai.updateServerStatus, {
        serverId,
        status: "deployed",
        deploymentUrl,
      });

      // Generate documentation
      await ctx.runAction(api.ai.generateDocumentation, { serverId });

      return { url: deploymentUrl, status: "deployed" };
    } catch (error: any) {
      await ctx.runMutation(api.ai.updateServerStatus, {
        serverId,
        status: "failed",
      });
      throw error;
    }
  },
});

// Mutation to update server status
export const updateServerStatus = mutation({
  args: {
    serverId: v.id("generatedServers"),
    status: v.union(
      v.literal("analyzing"),
      v.literal("generating"),
      v.literal("draft"),
      v.literal("deploying"),
      v.literal("deployed"),
      v.literal("failed")
    ),
    deploymentUrl: v.optional(v.string()),
  },
  handler: async (ctx, { serverId, status, deploymentUrl }) => {
    await ctx.db.patch(serverId, {
      status,
      ...(deploymentUrl && { deploymentUrl }),
    });
  },
});

// Action to generate documentation
export const generateDocumentation = action({
  args: {
    serverId: v.id("generatedServers"),
  },
  handler: async (ctx, { serverId }) => {
    const server = await ctx.runQuery(api.ai.getServer, { serverId });
    if (!server) {
      throw new Error("Server not found");
    }

    // Generate documentation using Claude
    const docs = await generateDocsHelper(server.code, server.tools);

    // Update server with documentation
    await ctx.runMutation(api.ai.updateServerDocs, {
      serverId,
      readme: docs.readme,
      toolDocs: docs.toolDocs,
    });
  },
});

// Mutation to update server documentation
export const updateServerDocs = mutation({
  args: {
    serverId: v.id("generatedServers"),
    readme: v.string(),
    toolDocs: v.array(
      v.object({
        name: v.string(),
        description: v.string(),
        params: v.string(),
        example: v.string(),
      })
    ),
  },
  handler: async (ctx, { serverId, readme, toolDocs }) => {
    await ctx.db.patch(serverId, {
      readme,
      toolDocs,
    });
  },
});

// Helper functions (these would use Claude API in production)

function parseOpenAPIEndpoints(spec: any): any[] {
  const endpoints = [];

  for (const [path, methods] of Object.entries(spec.paths || {})) {
    for (const [method, details] of Object.entries(methods as any)) {
      if (["get", "post", "put", "patch", "delete"].includes(method)) {
        endpoints.push({
          path,
          method: method.toUpperCase(),
          operationId: (details as any).operationId,
          summary: (details as any).summary,
          description: (details as any).description,
          parameters: (details as any).parameters || [],
          requestBody: (details as any).requestBody,
          responses: (details as any).responses,
        });
      }
    }
  }

  return endpoints;
}

function extractOpenAPISchemas(spec: any): any {
  return spec.components?.schemas || {};
}

async function generateMCPCode(params: {
  name: string;
  description: string;
  endpoints: any[];
  schemas: any;
  sourceType: string;
}): Promise<string> {
  // Use real Claude API to generate MCP server code
  const spec = {
    info: {
      title: params.name,
      description: params.description,
    },
    paths: {},
    components: {
      schemas: params.schemas,
    },
  };

  // Convert endpoints to OpenAPI paths format
  for (const endpoint of params.endpoints) {
    const path = endpoint.path || "/";
    if (!spec.paths[path]) {
      spec.paths[path] = {};
    }
    const method = (endpoint.method || "get").toLowerCase();
    spec.paths[path][method] = {
      operationId: endpoint.operationId,
      summary: endpoint.summary,
      description: endpoint.description,
      parameters: endpoint.parameters,
      requestBody: endpoint.requestBody,
      responses: endpoint.responses,
    };
  }

  const result = await generateMCPFromOpenAPI(spec);
  return result.code;
}

function extractToolsFromCode(code: string): any[] {
  // Parse the generated code and extract tool definitions
  // For now, return placeholder
  try {
    const parsed = JSON.parse(code);
    return (parsed.endpoints || []).map((endpoint: any) => ({
      name: endpoint.operationId || `${endpoint.method}_${endpoint.path}`.toLowerCase(),
      description: endpoint.summary || endpoint.description || "",
      schema: {
        type: "object",
        properties: {},
      },
    }));
  } catch {
    return [];
  }
}

async function analyzeAPIDocumentation(
  html: string,
  url: string
): Promise<{
  name: string;
  description: string;
  endpoints: any[];
  schemas: any;
}> {
  // Use real Claude API to analyze documentation
  const result = await generateMCPFromDocs(html, url);
  return {
    name: result.name,
    description: result.description,
    endpoints: result.endpoints,
    schemas: {},
  };
}

async function analyzeGitHubRepo(
  owner: string,
  repo: string
): Promise<{
  endpoints: any[];
  schemas: any;
}> {
  // Fetch key files from GitHub
  const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents`;
  const response = await fetch(apiUrl);

  if (!response.ok) {
    throw new Error("Failed to fetch repository contents");
  }

  const files = await response.json();

  // Download relevant files (routes, controllers, etc.)
  const relevantFiles: Array<{ path: string; content: string }> = [];

  for (const file of files.slice(0, 10)) { // Limit to first 10 files
    if (file.type === "file" && (file.name.endsWith(".ts") || file.name.endsWith(".js"))) {
      const contentResponse = await fetch(file.download_url);
      if (contentResponse.ok) {
        const content = await contentResponse.text();
        relevantFiles.push({
          path: file.path,
          content: content.slice(0, 5000), // Limit content size
        });
      }
    }
  }

  // Use Claude to analyze the code
  const result = await analyzeRepo(relevantFiles);

  return {
    endpoints: result.endpoints || [],
    schemas: {},
  };
}

async function deployToVercel(server: any): Promise<string> {
  // Use real Vercel API to deploy
  const result = await deployMCPServer({
    serverName: server.slug,
    serverCode: server.code,
    env: {},
  });

  // Check health
  const health = await checkMCPServerHealth(result.url);
  if (!health.ok) {
    throw new Error(`Deployment health check failed: ${health.error}`);
  }

  return result.url;
}

async function generateDocsHelper(
  code: string,
  tools: any[]
): Promise<{
  readme: string;
  toolDocs: any[];
}> {
  // Use real Claude API to generate documentation
  return await generateDocs(code, tools);
}
